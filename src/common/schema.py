from datetime import datetime
from typing import Annotated

from pydantic import BaseModel, ConfigDict, EmailStr, Field, validate_email

from src.core.settings import settings


CUSTOM_VALIDATION_ERROR_MESSAGES = {
    'no_such_attribute': "Object has no attribute '{attribute}'",
    'json_invalid': 'Invalid JSON: {error}',
    'json_type': 'JSON input should be a string, bytes, or byte array',
    'recursion_loop': 'Recursion error - cycle detected',
    'model_type': 'Input should be a valid dictionary or instance of {class_name}',
    'model_attributes_type': 'Input should be a valid dictionary or object with extractable fields',
    'dataclass_exact_type': 'Input should be an instance of {class_name}',
    'dataclass_type': 'Input should be a dictionary or instance of {class_name}',
    'missing': 'Field is required',
    'frozen_field': 'Field is frozen',
    'frozen_instance': 'Instance is frozen',
    'extra_forbidden': 'Extra inputs are not allowed',
    'invalid_key': 'Key should be a string',
    'get_attribute_error': 'Error retrieving attribute: {error}',
    'none_required': 'Input should be None',
    'enum': 'Input should be {expected}',
    'greater_than': 'Input should be greater than {gt}',
    'greater_than_equal': 'Input should be greater than or equal to {ge}',
    'less_than': 'Input should be less than {lt}',
    'less_than_equal': 'Input should be less than or equal to {le}',
    'finite_number': 'Input should be a finite number',
    'too_short': '{field_type} should have at least {min_length} items after validation, not {actual_length}',
    'too_long': '{field_type} should have at most {max_length} items after validation, not {actual_length}',
    'string_type': 'Input should be a valid string',
    'string_sub_type': 'Input should be a string, not an instance of a str subclass',
    'string_unicode': 'Input should be a valid string, raw data cannot be parsed as Unicode',
    'string_pattern_mismatch': "String should match the pattern '{pattern}'",
    'string_too_short': 'String should have at least {min_length} characters',
    'string_too_long': 'String should have at most {max_length} characters',
    'dict_type': 'Input should be a valid dictionary',
    'mapping_type': 'Input should be a valid mapping, error: {error}',
    'iterable_type': 'Input should be an iterable',
    'iteration_error': 'Error while iterating, error: {error}',
    'list_type': 'Input should be a valid list',
    'tuple_type': 'Input should be a valid tuple',
    'set_type': 'Input should be a valid set',
    'bool_type': 'Input should be a valid boolean',
    'bool_parsing': 'Input should be a valid boolean, unable to interpret input',
    'int_type': 'Input should be a valid integer',
    'int_parsing': 'Input should be a valid integer, unable to parse as integer',
    'int_parsing_size': 'Unable to parse input as an integer, exceeds maximum size',
    'int_from_float': 'Input should be a valid integer, got a number with a fractional part',
    'multiple_of': 'Input should be a multiple of {multiple_of}',
    'float_type': 'Input should be a valid number',
    'float_parsing': 'Input should be a valid number, unable to parse as number',
    'bytes_type': 'Input should be valid bytes',
    'bytes_too_short': 'Data should have at least {min_length} bytes',
    'bytes_too_long': 'Data should have at most {max_length} bytes',
    'value_error': 'Value error, {error}',
    'assertion_error': 'Assertion failed, {error}',
    'literal_error': 'Input should be {expected}',
    'date_type': 'Input should be a valid date',
    'date_parsing': 'Input should be a valid date in YYYY-MM-DD format, {error}',
    'date_from_datetime_parsing': 'Input should be a valid date or datetime, {error}',
    'date_from_datetime_inexact': 'Datetime provided should have zero time for precise date',
    'date_past': 'Date should be in the past',
    'date_future': 'Date should be in the future',
    'time_type': 'Input should be a valid time',
    'time_parsing': 'Input should be a valid time format, {error}',
    'datetime_type': 'Input should be a valid datetime',
    'datetime_parsing': 'Input should be a valid datetime, {error}',
    'datetime_object_invalid': 'Invalid datetime object, got {error}',
    'datetime_past': 'Input should be in the past',
    'datetime_future': 'Input should be in the future',
    'timezone_naive': 'Input should not include timezone information',
    'timezone_aware': 'Input should include timezone information',
    'timezone_offset': 'Expected timezone offset {tz_expected}, got {tz_actual}',
    'time_delta_type': 'Input should be a valid time delta',
    'time_delta_parsing': 'Input should be a valid time delta, {error}',
    'frozen_set_type': 'Input should be a valid frozen set',
    'is_instance_of': 'Input should be an instance of {class}',
    'is_subclass_of': 'Input should be a subclass of {class}',
    'callable_type': 'Input should be a callable',
    'union_tag_invalid': "Union tag '{tag}' from {discriminator} does not match any expected tags: {expected_tags}",
    'union_tag_not_found': 'Unable to extract tag using discriminator {discriminator}',
    'arguments_type': 'Arguments must be a tuple, list, or dictionary',
    'missing_argument': 'Required argument missing',
    'unexpected_keyword_argument': 'Unexpected keyword argument',
    'missing_keyword_only_argument': 'Required keyword-only argument missing',
    'unexpected_positional_argument': 'Unexpected positional argument',
    'missing_positional_only_argument': 'Required positional-only argument missing',
    'multiple_argument_values': 'Multiple values provided for the same argument',
}

class SchemaBase(BaseModel):
    """Base model configuration"""
    model_config = ConfigDict(
        from_attributes=True,
        use_enum_values=True,
        json_encoders={datetime: lambda x: x.strftime(settings.DATETIME_FORMAT)},
    )